function I = integral2D(X,Y,Z,rule)

% Integrates Z(X,Y) over the full [X,Y] range using 
% the optional argument rule = ['trap'] or 'simpson'
% X,Y, and Z must be the same size, with X and Y plaid, monotonic and
% uniform like generated by meshgrid

if nargin < 4
    % If we have a midpoint - use simpson
    [Nx,Ny] = size(Z);
    if mod(Nx,2) == 0 || mod(Ny,2) == 0
        rule = 'trap';
    else
        rule = 'simp';
    end
end

assert(all(size(X) == size(Y)) && all(size(Y) == size(Z)),'Input vectors must be the same size');
assert(ndims(Z) == 2,'Inputs X, Y and Z must be 2D matrices');

% Test for equal rows in X, and equal columns in Y (plaid)
rowEq = all(all(bsxfun(@eq,X,X(1,:))));
colEq = all(all(bsxfun(@eq,Y,Y(:,1))));
plaid = rowEq && colEq;
assert(plaid,'All rows of X must be equal, and all columns of Y')
% Test for monotonic
diffX = diff(X(1,:));
diffY = diff(Y(:,1));
monX = all(diffX>0);
monY = all(diffY>0);
mon = monX && monY;
assert(mon,'X and Y must contain monotonically increasing elements')
% Test for uniform
eps = 1e-10;
unX = all(abs(diffX - median(diffX)) < eps);
unY = all(abs(diffY - median(diffY)) < eps);
un = unX && unY;
assert(un,'X and Y must contain uniformly increasing elements')


switch rule
    case 'trap'
        I = trapz(X(1,:),trapz(Y(:,1),Z));
    case 'simp'
        [Nx,Ny] = size(Z);
        Ic = zeros(1,Ny);
        for yy = 1:Ny
            Ic(yy) = simpsons(Z(:,yy),min(Y(:,yy)),max(Y(:,yy)),[]);
        end
        I = simpsons(Ic,min(X(1,:)),max(X(1,:)),[]);
    otherwise
        error(['Unknown rule: ',rule])
end

